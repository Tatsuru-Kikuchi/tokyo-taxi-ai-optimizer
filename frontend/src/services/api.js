/**\n * API Service for Tokyo Taxi AI Optimizer\n * Handles all communication with the backend APIs\n */\n\nconst API_BASE_URL = process.env.REACT_APP_API_URL || '/api/v1';\n\nclass APIService {\n  constructor() {\n    this.baseURL = API_BASE_URL;\n    this.cache = new Map();\n    this.cacheTimeout = 30000; // 30 seconds\n  }\n\n  /**\n   * Generic fetch wrapper with error handling and caching\n   */\n  async fetchWithCache(endpoint, options = {}) {\n    const cacheKey = `${endpoint}-${JSON.stringify(options)}`;\n    const cachedData = this.cache.get(cacheKey);\n    \n    if (cachedData && Date.now() - cachedData.timestamp < this.cacheTimeout) {\n      return cachedData.data;\n    }\n\n    try {\n      const response = await fetch(`${this.baseURL}${endpoint}`, {\n        headers: {\n          'Content-Type': 'application/json',\n          ...options.headers,\n        },\n        ...options,\n      });\n\n      if (!response.ok) {\n        throw new Error(`API Error: ${response.status} ${response.statusText}`);\n      }\n\n      const data = await response.json();\n      \n      // Cache successful responses\n      this.cache.set(cacheKey, {\n        data,\n        timestamp: Date.now()\n      });\n\n      return data;\n    } catch (error) {\n      console.error('API Request failed:', error);\n      \n      // Return cached data if available on error\n      if (cachedData) {\n        console.warn('Using stale cached data due to API error');\n        return cachedData.data;\n      }\n      \n      throw error;\n    }\n  }\n\n  /**\n   * Get current weather data\n   */\n  async getWeatherData() {\n    return this.fetchWithCache('/weather');\n  }\n\n  /**\n   * Get current traffic data\n   */\n  async getTrafficData() {\n    return this.fetchWithCache('/traffic');\n  }\n\n  /**\n   * Get demand hotspots\n   */\n  async getHotspots(userType = 'driver', limit = 10) {\n    return this.fetchWithCache(`/hotspots?user_type=${userType}&limit=${limit}`);\n  }\n\n  /**\n   * Get personalized recommendations\n   */\n  async getRecommendations(userType, location = null) {\n    let endpoint = `/recommendations/${userType}`;\n    \n    if (location && location.latitude && location.longitude) {\n      endpoint += `?location_lat=${location.latitude}&location_lng=${location.longitude}`;\n    }\n    \n    return this.fetchWithCache(endpoint);\n  }\n\n  /**\n   * Get research summary\n   */\n  async getResearchSummary() {\n    return this.fetchWithCache('/research/summary');\n  }\n\n  /**\n   * Get system health status\n   */\n  async getSystemHealth() {\n    return this.fetchWithCache('/system/health');\n  }\n\n  /**\n   * Get performance statistics\n   */\n  async getPerformanceStats() {\n    return this.fetchWithCache('/stats/performance');\n  }\n\n  /**\n   * Get comprehensive optimization data (combines multiple endpoints)\n   */\n  async getOptimizationData(userType = 'driver', location = null) {\n    try {\n      const [weather, traffic, hotspots, recommendations] = await Promise.all([\n        this.getWeatherData(),\n        this.getTrafficData(),\n        this.getHotspots(userType),\n        this.getRecommendations(userType, location)\n      ]);\n\n      return {\n        weather: weather.data,\n        traffic: traffic.data,\n        hotspots: hotspots.data.hotspots,\n        recommendations: recommendations.data.recommendations,\n        timestamp: new Date().toISOString(),\n        userType,\n        location\n      };\n    } catch (error) {\n      console.error('Failed to get optimization data:', error);\n      \n      // Return fallback data\n      return this.getFallbackData(userType);\n    }\n  }\n\n  /**\n   * Fallback data when API is unavailable\n   */\n  getFallbackData(userType) {\n    return {\n      weather: {\n        temperature: 22,\n        is_raining: false,\n        description: 'Clear (Offline Mode)',\n        confidence: 50\n      },\n      traffic: {\n        punctuality_rate: 94.0,\n        active_disruptions: 0,\n        average_delay: 1.0\n      },\n      hotspots: [\n        {\n          name: 'Ginza',\n          ai_revenue_per_min: 68.1,\n          traditional_revenue_per_min: 52.3,\n          improvement_percentage: 30.2,\n          confidence_score: 85,\n          ai_wait_time: 4.2\n        },\n        {\n          name: 'Shibuya',\n          ai_revenue_per_min: 64.8,\n          traditional_revenue_per_min: 49.7,\n          improvement_percentage: 30.4,\n          confidence_score: 87,\n          ai_wait_time: 4.5\n        }\n      ],\n      recommendations: [\n        {\n          type: 'positioning',\n          title: 'Offline Mode Active',\n          description: 'Using cached data. Reconnect for real-time optimization.',\n          priority: 'medium',\n          confidence: 50\n        }\n      ],\n      timestamp: new Date().toISOString(),\n      userType,\n      offline: true\n    };\n  }\n\n  /**\n   * Clear API cache\n   */\n  clearCache() {\n    this.cache.clear();\n  }\n\n  /**\n   * Check if API is available\n   */\n  async checkAPIStatus() {\n    try {\n      const response = await fetch(`${this.baseURL}/system/health`, {\n        method: 'HEAD',\n        timeout: 5000\n      });\n      return response.ok;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * Get user's location (with permission)\n   */\n  async getUserLocation() {\n    return new Promise((resolve, reject) => {\n      if (!navigator.geolocation) {\n        reject(new Error('Geolocation is not supported'));\n        return;\n      }\n\n      navigator.geolocation.getCurrentPosition(\n        (position) => {\n          resolve({\n            latitude: position.coords.latitude,\n            longitude: position.coords.longitude,\n            accuracy: position.coords.accuracy\n          });\n        },\n        (error) => {\n          console.warn('Geolocation error:', error);\n          // Fallback to Tokyo center\n          resolve({\n            latitude: 35.6762,\n            longitude: 139.6503,\n            accuracy: null,\n            fallback: true\n          });\n        },\n        {\n          enableHighAccuracy: true,\n          timeout: 10000,\n          maximumAge: 300000 // 5 minutes\n        }\n      );\n    });\n  }\n\n  /**\n   * Real-time data subscription (WebSocket simulation)\n   */\n  subscribeToRealTimeUpdates(callback, interval = 30000) {\n    const updateInterval = setInterval(async () => {\n      try {\n        // Clear cache to force fresh data\n        this.clearCache();\n        \n        const data = await this.getOptimizationData();\n        callback(data);\n      } catch (error) {\n        console.error('Real-time update failed:', error);\n      }\n    }, interval);\n\n    // Return cleanup function\n    return () => {\n      clearInterval(updateInterval);\n    };\n  }\n}\n\n// Create singleton instance\nconst apiService = new APIService();\n\nexport default apiService;\n\n// Named exports for specific functions\nexport {\n  apiService as API,\n};\n\n// Hook for React components\nexport const useAPI = () => {\n  return apiService;\n};\n\n// Custom hook for optimization data\nexport const useOptimizationData = (userType = 'driver', autoRefresh = true) => {\n  const [data, setData] = React.useState(null);\n  const [loading, setLoading] = React.useState(true);\n  const [error, setError] = React.useState(null);\n\n  React.useEffect(() => {\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n        \n        const result = await apiService.getOptimizationData(userType);\n        setData(result);\n      } catch (err) {\n        setError(err.message);\n        // Use fallback data on error\n        setData(apiService.getFallbackData(userType));\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n\n    // Set up auto-refresh if enabled\n    let cleanup = null;\n    if (autoRefresh) {\n      cleanup = apiService.subscribeToRealTimeUpdates(setData, 30000);\n    }\n\n    return cleanup;\n  }, [userType, autoRefresh]);\n\n  return { data, loading, error, refresh: () => fetchData() };\n};\n"